# Everything you need to know about Packages in Go

## A complete overview of package management and deployment in Go programming language  Goç¼–ç¨‹è¯­è¨€çš„è½¯ä»¶åŒ…ç®¡ç†å’Œéƒ¨ç½²çš„å®Œæ•´æ¦‚è¿°

## Migrate to Go Modules

Go provides a new feature called **Modules** which provides flexibility to manage your project and dependencies with ease. If you are working on Go packages, then you should consider **relocating** your project to Go Modules.  Goæä¾›äº†ä¸€ä¸ªç§°ä¸º Modules çš„æ–°åŠŸèƒ½ï¼Œè¯¥åŠŸèƒ½æä¾›äº†è½»æ¾ç®¡ç†é¡¹ç›®å’Œä¾èµ–é¡¹çš„çµæ´»æ€§ã€‚ å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨Goè½¯ä»¶åŒ…ï¼Œåˆ™åº”è€ƒè™‘å°†é¡¹ç›®é‡æ–°å®šä½åˆ°Go Modulesã€‚

If you are familiar to languages like **Java** or **JavaScript** on **Node**, then you might be quite familiar with **packages**. A package is nothing but a directory with some code files, which exposes different variables (*features*) from a single point of reference. Let me explain, what that means.  å¦‚æœæ‚¨ç†Ÿæ‚‰Nodeä¸Šçš„Javaæˆ–JavaScriptä¹‹ç±»çš„è¯­è¨€ï¼Œé‚£ä¹ˆæ‚¨å¯èƒ½å¯¹è½¯ä»¶åŒ…éå¸¸ç†Ÿæ‚‰ã€‚ åŒ…ä¸è¿‡æ˜¯å¸¦æœ‰ä¸€äº›ä»£ç æ–‡ä»¶çš„ç›®å½•ï¼Œè¯¥ç›®å½•ä»å•ä¸ªå¼•ç”¨ç‚¹å…¬å¼€ä¸åŒçš„å˜é‡ï¼ˆåŠŸèƒ½ï¼‰ã€‚ è®©æˆ‘è§£é‡Šä¸€ä¸‹ï¼Œè¿™æ„å‘³ç€ä»€ä¹ˆã€‚

Imagine you have more than a thousand functions that you need constantly while working on any project. Some of these functions have common behavior. For example, `toUpperCase` and `toLowerCase` function transforms **case** of a `string`, so you write them in a single file (*probably* ***case.go\***). There are other functions which do some other operations on `string` data type, so you write them in a separate file.  æƒ³è±¡ä¸€ä¸‹ï¼Œåœ¨å¤„ç†ä»»ä½•é¡¹ç›®æ—¶ï¼Œæ‚¨éœ€è¦ä¸æ–­åœ°æ‹¥æœ‰ä¸Šåƒç§åŠŸèƒ½ã€‚ å…¶ä¸­ä¸€äº›åŠŸèƒ½å…·æœ‰å…±åŒçš„è¡Œä¸ºã€‚ ä¾‹å¦‚ï¼ŒtoUpperCaseå’ŒtoLowerCaseå‡½æ•°è½¬æ¢å­—ç¬¦ä¸²çš„å¤§å°å†™ï¼Œå› æ­¤æ‚¨å°†å®ƒä»¬å†™å…¥å•ä¸ªæ–‡ä»¶ï¼ˆå¯èƒ½ä¸ºcase.goï¼‰ã€‚ è¿˜æœ‰å…¶ä»–å‡½æ•°å¯ä»¥å¯¹å­—ç¬¦ä¸²æ•°æ®ç±»å‹æ‰§è¡Œå…¶ä»–ä¸€äº›æ“ä½œï¼Œå› æ­¤æ‚¨å¯ä»¥å°†å®ƒä»¬å†™å…¥å•ç‹¬çš„æ–‡ä»¶ä¸­ã€‚

Since you have many files which do something with `string` data type, so you created a directory named `string` and put all `string` related files into it. Finally, you put all of these directories in one parent directory which will be your package. The whole package structure looks like below.  ç”±äºæ‚¨æœ‰è®¸å¤šæ–‡ä»¶å¯ä»¥å¤„ç†å­—ç¬¦ä¸²æ•°æ®ç±»å‹ï¼Œå› æ­¤æ‚¨åˆ›å»ºäº†ä¸€ä¸ªåä¸ºstringçš„ç›®å½•ï¼Œå¹¶å°†æ‰€æœ‰ä¸å­—ç¬¦ä¸²ç›¸å…³çš„æ–‡ä»¶æ”¾å…¥å…¶ä¸­ã€‚ æœ€åï¼Œå°†æ‰€æœ‰è¿™äº›ç›®å½•æ”¾åœ¨ä¸€ä¸ªçˆ¶ç›®å½•ä¸­ï¼Œè¯¥ç›®å½•å°†æˆä¸ºæ‚¨çš„ç¨‹åºåŒ…ã€‚ æ•´ä¸ªç¨‹åºåŒ…ç»“æ„å¦‚ä¸‹æ‰€ç¤ºã€‚

```
package-name
â”œâ”€â”€ string
|  â”œâ”€â”€ case.go
|  â”œâ”€â”€ trim.go
|  â””â”€â”€ misc.go
â””â”€â”€ number
   â”œâ”€â”€ arithmetics.go
   â””â”€â”€ primes.go
```

I will explain thoroughly, how we can import functions and variables from a package and how everything blends together to form a package, but for now, imagine your package as a directory containing `.go` files.  æˆ‘å°†è¯¦ç»†è§£é‡Šå¦‚ä½•ä»åŒ…ä¸­å¯¼å…¥å‡½æ•°å’Œå˜é‡ï¼Œä»¥åŠå¦‚ä½•å°†æ‰€æœ‰å†…å®¹èåˆåœ¨ä¸€èµ·å½¢æˆä¸€ä¸ªåŒ…ï¼Œä½†æ˜¯ç°åœ¨ï¼Œå°†æ‚¨çš„åŒ…æƒ³è±¡æˆä¸€ä¸ªåŒ…å«.goæ–‡ä»¶çš„ç›®å½•ã€‚

Every Go program **must be** a part of some package. As discussed in [**Getting started with Go**](https://medium.com/rungo/working-in-go-workspace-3b0576e0534a) lesson, a standalone executable Go program must have `package main` declaration. If a program is part of the main package, then `go install` will create a binary file; which upon execution calls `main` function of the program. If a program is part of a package other than `main`, then a **package archive** file is created with `go install` command. **Donâ€™t worry, I will explain all this in upcoming topics.**  æ¯ä¸ªGoç¨‹åºéƒ½å¿…é¡»æ˜¯æŸäº›ç¨‹åºåŒ…çš„ä¸€éƒ¨åˆ†ã€‚ å¦‚Goå…¥é—¨è¯¾ç¨‹ä¸­æ‰€è¿°ï¼Œç‹¬ç«‹çš„å¯æ‰§è¡ŒGoç¨‹åºå¿…é¡»å…·æœ‰åŒ…mainå£°æ˜ã€‚ å¦‚æœç¨‹åºæ˜¯ä¸»è½¯ä»¶åŒ…çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆgo installå°†åˆ›å»ºä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ï¼› åœ¨æ‰§è¡Œæ—¶è°ƒç”¨ç¨‹åºçš„ä¸»è¦åŠŸèƒ½ã€‚ å¦‚æœç¨‹åºä¸æ˜¯mainåŒ…çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™ä½¿ç”¨go installå‘½ä»¤åˆ›å»ºä¸€ä¸ªåŒ…å½’æ¡£æ–‡ä»¶ã€‚ ä¸ç”¨æ‹…å¿ƒï¼Œæˆ‘å°†åœ¨æ¥ä¸‹æ¥çš„ä¸»é¢˜ä¸­è§£é‡Šæ‰€æœ‰è¿™äº›ã€‚

Letâ€™s create an executable package. As we know, to create a binary executable file, we need our program to be a part of `main` package and it must have `main` function which is the entry point of execution.

![Image for post](./images/02_01.png)

A package name is the name of the directory contained in `src` directory. In the above case, `app` is the package since `app` is the child directory of `src` directory. Hence, `go install app` command looked for `app` sub-directory inside `src` directory of `GOPATH` (*since* `*GOROOT*` *doesnâ€™t have it*).  è½¯ä»¶åŒ…åç§°æ˜¯srcç›®å½•ä¸­åŒ…å«çš„ç›®å½•çš„åç§°ã€‚ åœ¨ä¸Šè¿°æƒ…å†µä¸‹ï¼Œå› ä¸ºappæ˜¯srcç›®å½•çš„å­ç›®å½•ï¼Œæ‰€ä»¥appæ˜¯è½¯ä»¶åŒ…ã€‚ å› æ­¤ï¼Œæ‰§è¡Œgo install appå‘½ä»¤ä¼šåœ¨GOPATHçš„srcç›®å½•ä¸­æŸ¥æ‰¾appå­ç›®å½•ï¼ˆå› ä¸ºGOROOTæ²¡æœ‰ï¼‰ã€‚

Then it compiled the package and created `app` binary executable file (*same as the package name*) inside `bin` directory (*set by* `*GOBIN*`) which should be executable from the terminal since `bin` directory in the `PATH`.

> *ğŸ’¡* **Package declaration** which should be first line of code like `*package main*` in above example, can be different than package name. Hence, you might find some packages where package name (**name of the directory**) is different than package declaration. When you import a package, package declaration is used to create **package reference variable**, explained later in the article.

`go install ` command looks for any file with `**main**` **package declaration** inside given `package` directory. If it finds a file, then Go knows this is an executable program and it needs to create a binary file. A package can have many files but only one file with `**main**` function, since that file will be the entry point of the execution.  go install <package>å‘½ä»¤åœ¨ç»™å®šçš„è½¯ä»¶åŒ…ç›®å½•ä¸­æŸ¥æ‰¾å…·æœ‰ä¸»è½¯ä»¶åŒ…å£°æ˜çš„ä»»ä½•æ–‡ä»¶ã€‚ å¦‚æœæ‰¾åˆ°æ–‡ä»¶ï¼Œåˆ™GoçŸ¥é“è¿™æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºï¼Œå› æ­¤éœ€è¦åˆ›å»ºä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ã€‚ ä¸€ä¸ªåŒ…å¯ä»¥æœ‰è®¸å¤šæ–‡ä»¶ï¼Œä½†åªæœ‰ä¸€ä¸ªå…·æœ‰ä¸»è¦åŠŸèƒ½çš„æ–‡ä»¶ï¼Œå› ä¸ºè¯¥æ–‡ä»¶å°†æˆä¸ºæ‰§è¡Œçš„å…¥å£ã€‚

If a package does not contain a file with `main` package declaration, then Go creates a **package archive** (`.a`) file inside `pkg` directory.

![Image for post](./images/02_02.png)

Since, `app` is not an executable package, it created `app.a` file inside `pkg` directory. We can not execute this file as itâ€™s not a binary executable file.

## Package naming convention

Go community recommends to use plain and simple names for packages. For example, `strutils` for **string utility** functions or `http` for HTTP requests related functions. A package names with `under_scores`, `hy-phens` or `mixedCaps` should be avoided.  Goç¤¾åŒºå»ºè®®å¯¹è½¯ä»¶åŒ…ä½¿ç”¨ç®€å•çš„åç§°ã€‚ ä¾‹å¦‚ï¼Œç”¨äºå­—ç¬¦ä¸²å®ç”¨ç¨‹åºåŠŸèƒ½çš„strutilsæˆ–ç”¨äºHTTPè¯·æ±‚ç›¸å…³åŠŸèƒ½çš„httpã€‚ åº”è¯¥é¿å…ä½¿ç”¨under_scoresï¼Œè¿å­—ç¬¦æˆ–mixedCapsçš„è½¯ä»¶åŒ…åç§°ã€‚

------

# Creating a package

As we discussed, there are two types of packages. An **executable package** and a **utility package**. An executable package is your main application since you will be running it. A utility package is not self-executable, instead, it enhances the functionality of an executable package by providing utility functions and other important assets.  æ­£å¦‚æˆ‘ä»¬æ‰€è®¨è®ºçš„ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„è½¯ä»¶åŒ…ã€‚ å¯æ‰§è¡Œç¨‹åºåŒ…å’Œå®ç”¨ç¨‹åºåŒ…ã€‚ å¯æ‰§è¡Œè½¯ä»¶åŒ…æ˜¯æ‚¨çš„ä¸»è¦åº”ç”¨ç¨‹åºï¼Œå› ä¸ºæ‚¨å°†åœ¨è¿è¡Œå®ƒã€‚ å®ç”¨ç¨‹åºåŒ…ä¸æ˜¯è‡ªå¯æ‰§è¡Œçš„ï¼Œç›¸åï¼Œå®ƒé€šè¿‡æä¾›å®ç”¨ç¨‹åºåŠŸèƒ½å’Œå…¶ä»–é‡è¦èµ„äº§æ¥å¢å¼ºå¯æ‰§è¡Œç¨‹åºåŒ…çš„åŠŸèƒ½ã€‚

As we know, a package is nothing but a directory. Letâ€™s create `greet` directory inside `src` and put some files in it. This time, we will write `package greet` a declaration on the top of each file to state that this is a utility package.  ä¼—æ‰€å‘¨çŸ¥ï¼ŒåŒ…åªä¸è¿‡æ˜¯ç›®å½•ã€‚ è®©æˆ‘ä»¬åœ¨srcä¸­åˆ›å»ºgreetç›®å½•ï¼Œå¹¶å°†ä¸€äº›æ–‡ä»¶æ”¾å…¥å…¶ä¸­ã€‚ è¿™æ¬¡ï¼Œæˆ‘ä»¬å°†åœ¨æ¯ä¸ªæ–‡ä»¶çš„é¡¶éƒ¨å†™ä¸€ä¸ªâ€œ greetingâ€åŒ…ï¼Œä»¥å£°æ˜è¿™æ˜¯ä¸€ä¸ªå®ç”¨ç¨‹åºåŒ…ã€‚

![Image for post](./images/02_03.png)

## Export members

A utility package is supposed to provide some **variables** to a package who imports it. Like `export` syntax in `JavaScript`, Go exports a variable if a variable name starts with **Uppercase**. All other variables not starting with an uppercase letter is private to the package.  å®ç”¨ç¨‹åºåŒ…åº”è¯¥ä¸ºå¯¼å…¥å®ƒçš„åŒ…æä¾›ä¸€äº›å˜é‡ã€‚ ä¸JavaScriptä¸­çš„å¯¼å‡ºè¯­æ³•ä¸€æ ·ï¼Œå¦‚æœå˜é‡åç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œåˆ™Goä¼šå¯¼å‡ºå˜é‡ã€‚ æ‰€æœ‰å…¶ä»–ä¸ä»¥å¤§å†™å­—æ¯å¼€å¤´çš„å˜é‡å¯¹ç¨‹åºåŒ…éƒ½æ˜¯ç§æœ‰çš„ã€‚

> *âš ï¸* I am going to use **variable** word from now on in this article, to describe an export member but export members can be of any type like `*constant*`, `*map*`, `*function*`, `*struct*`, `*array*`, `*slice*` etc.

Letâ€™s export a greeting variable from `day.go` file.

![Image for post](./images/02_04.png)

In the above program, `Morning` variable will be exported from the package but not the `morning` variable since it starts with a lowercase letter.

## Importing a package

Now, we need an **executable package** which will consume our `greet` package. Letâ€™s create an `app` directory inside `src` and create `entry.go` file with `main` package declaration and `main` function. Note here, Go packages do not have an **entry file naming system** like `index.js` in Node. For an executable package, a file with `main` function is the entry file for execution.

To import a package, we use `import` syntax followed by the **package name**.

> *ğŸ’¡* Unlike other programming languages, a package name can also be a subpath like `*some-dir/****greet\***` and Go will automatically resolve the path to the `***greet\***` package for us as you will see in the **nested package** topic ahead.

Go first searches for package directory inside `**GOROOT**/src` directory and if it doesnâ€™t find the package, then it looks for `**GOPATH**/src`. Since, `fmt` package is part of Goâ€™s standard library which is located in `GOROOT/src`, it is imported from there. But since Go cannot find `greet` package inside `GOROOT`, it will lookup inside `GOPATH/src` and we have it there.

![Image for post](./images/02_05.png)

Above program throws compilation error, as `morning` variable is not visible from the package `greet`. As you can see, we use `.` (*dot*) notation to access exported members from a package. When you import a package, Go creates a global variable using the **package declaration** of the package. In the above case, `greet` is the global variable created by Go because we used `package greet` declaration in programs contained in `greet` package.

![Image for post](./images/02_06.png)

We can group `fmt` and `greet` package imports together using grouping syntax (*parentheses*). This time, our program will compile just fine, because `Morning` variable is exported from the `greet` package.

> *ğŸ’¡* BTW, you can run an executable Go package from anywhere using `go run ` command. Go will try to resolve the package from `GOROOT` or `GOPATH` directories and execute the `main` function. Hence, in the above example, you could have just executed the `go run app` command.  é¡ºä¾¿è¯´ä¸€å¥ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨go run <package-name>å‘½ä»¤ä»ä»»ä½•åœ°æ–¹è¿è¡Œå¯æ‰§è¡Œçš„Goè½¯ä»¶åŒ…ã€‚ Goå°†å°è¯•ä»GOROOTæˆ–GOPATHç›®å½•è§£æè¯¥ç¨‹åºåŒ…å¹¶æ‰§è¡Œmainå‡½æ•°ã€‚ å› æ­¤ï¼Œåœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæ‚¨å¯èƒ½åˆšåˆšæ‰§è¡Œäº†go run appå‘½ä»¤ã€‚

## Nested package

We can nest a package inside a package. Since for Go, a package is just a directory, itâ€™s like creating a subdirectory inside an already existing package. All we have to do is write an appropriate package declaration and provide a relative path of the nested package when we import it.  æˆ‘ä»¬å¯ä»¥å°†åŒ…åµŒå¥—åœ¨åŒ…ä¸­ã€‚ ç”±äºå¯¹äºGoï¼ŒåŒ…åªæ˜¯ç›®å½•ï¼Œå°±åƒåœ¨ç°æœ‰åŒ…ä¸­åˆ›å»ºå­ç›®å½•ä¸€æ ·ã€‚ æˆ‘ä»¬è¦åšçš„å°±æ˜¯ç¼–å†™ä¸€ä¸ªé€‚å½“çš„ç¨‹åºåŒ…å£°æ˜ï¼Œå¹¶åœ¨å¯¼å…¥æ—¶æä¾›åµŒå¥—ç¨‹åºåŒ…çš„ç›¸å¯¹è·¯å¾„ã€‚

![Image for post](./images/02_07.png)

![Image for post](./images/02_08.png)

As you can see from the above example, Go has created the `de` variable from the `greet/de` package import which contains all the exports from the `de` sub-package. The `de` variable name comes from the `package de` declaration.

## Package compilation

As discussed in the previous lesson, `go run` command compiles and executes a program. We know, `go install` command compiles a package and creates a binary executable file or package archive file.

The package archive file is created to avoid compilation of the package every single time it is imported in a program. The `go install` command pre-compiles a package and Go refers to `.a` files.

> *ğŸ’¡* Generally, when you install a 3rd party package, Go compiles the package and create package archive file. If you have created a package locally, then your **IDE** might create package archive as soon as you save the file in the package or when package gets modified. **VSCode compiles the package when you save it if you have** [**Go**](https://marketplace.visualstudio.com/items?itemName=ms-vscode.Go) **plugin installed.**  é€šå¸¸ï¼Œå½“æ‚¨å®‰è£…ç¬¬ä¸‰æ–¹è½¯ä»¶åŒ…æ—¶ï¼ŒGoä¼šç¼–è¯‘è¯¥è½¯ä»¶åŒ…å¹¶åˆ›å»ºè½¯ä»¶åŒ…å­˜æ¡£æ–‡ä»¶ã€‚ å¦‚æœæ‚¨æ˜¯åœ¨æœ¬åœ°åˆ›å»ºçš„ï¼Œåˆ™IDEå¯èƒ½ä¼šåœ¨å°†æ–‡ä»¶ä¿å­˜åˆ°åŒ…ä¸­æˆ–ä¿®æ”¹åŒ…åç«‹å³åˆ›å»ºåŒ…å½’æ¡£æ–‡ä»¶ã€‚ å¦‚æœå·²å®‰è£…Goæ’ä»¶ï¼Œåˆ™VSCodeåœ¨ä¿å­˜æ—¶ä¼šç¼–è¯‘è¯¥è½¯ä»¶åŒ…ã€‚

![Image for post](./images/02_09.png)

However, the nested packages wonâ€™t be compiled into archive files when you use `go install ` command. To create an archive file for the nested package, you need to use the same command but will the nested package path like `go install greet/de` in the previous example.

![Image for post](./images/02_10.png)

------

# Package initialization

When we run a Go program, the Go compiler follows a certain execution order for packages, files in a package and variable declaration in those files.  å½“æˆ‘ä»¬è¿è¡ŒGoç¨‹åºæ—¶ï¼ŒGoç¼–è¯‘å™¨ä¼šæŒ‰ç…§ä¸€å®šçš„æ‰§è¡Œé¡ºåºæ‰§è¡Œç¨‹åºåŒ…ï¼Œç¨‹åºåŒ…ä¸­çš„æ–‡ä»¶ä»¥åŠè¿™äº›æ–‡ä»¶ä¸­çš„å˜é‡å£°æ˜ã€‚

## Package scope

**A scope is a region in a code block where a defined variable is accessible**. A package scope is a region within a package where a declared variable is accessible from within a package (*across all the files in the package*). This region is the top-most block of any file in the package.  èŒƒå›´æ˜¯ä»£ç å—ä¸­å¯è®¿é—®å®šä¹‰å˜é‡çš„åŒºåŸŸã€‚ åŒ…ä½œç”¨åŸŸæ˜¯åŒ…ä¸­çš„ä¸€ä¸ªåŒºåŸŸï¼Œåœ¨è¯¥åŒºåŸŸä¸­ï¼Œå¯ä»¥ä»åŒ…å†…ï¼ˆè·¨åŒ…ä¸­çš„æ‰€æœ‰æ–‡ä»¶ï¼‰è®¿é—®å·²å£°æ˜çš„å˜é‡ã€‚ æ­¤åŒºåŸŸæ˜¯è½¯ä»¶åŒ…ä¸­ä»»ä½•æ–‡ä»¶çš„æœ€ä¸Šé¢çš„å—ã€‚

![Image for post](./images/02_11.png)

![Image for post](./images/02_12.png)

Take a look at `go run` command. This time, instead of executing one file, we have a glob pattern to include all the files inside `app` package for execution.

Go is smart enough to figure out an entry point of the application which is `entry.go` because it has `main` function. We can also use a command like below (*the filename order doesnâ€™t matter*).

```
go run src/app/version.go src/app/entry.go
```

> *ğŸ’¡* You can also use `*go run app*` command which does the same thing and this is a **better approach** to execute a package. `*go install*` or `*go build*` command requires a package name, which includes all the files inside a package, so we donâ€™t have to specify them like above.

Coming back to our main issue, we can use variable `version` declared in `version.go` file from anywhere in the package even though it is **not exported** (*like* `*Version*`), because it is declared in package scope.

If the `version` variable would have been declared inside a function, it wouldnâ€™t have been in the package scope and the above program would have failed to compile.

**You are not allowed to redeclare a global variable with the same name in the same package**. Hence, once `version` variable is declared, it can not be redeclared in the package scope. But you are free to re-declare elsewhere.

![Image for post](./images/02_13.png)

## Variable initialization

When a variable `a` depends on another variable `b`, `b` should be defined beforehand, else program wonâ€™t compile. Go follows this rule inside functions.

![Image for post]((./images/02_14.png)

But when these variables are defined in package scope, they are declared in initialization cycles. Letâ€™s have a look at the simple example below.

![Image for post](./images/02_15.png)

In the above example, first `c` is declared because its value is already declared. In later initialization cycle, `b` is declared, because it depends on `c` and value of `c` is already declared. In the final initialization cycle, `a` is declared and assigned to the value of `b`. Go can handle complex initialization cycles like below.

![Image for post](./images/02_16.png)

In the above example, first `c` will be declared and then `b` as its value depends on `c` and finally `a` as its value depends on `b`. You should avoid any initialization loop like below where initialization gets into a recursive **loop**.

![Image for post](./images/02_17.png)

Another example of package scope would be, having a function `f` in a separate file which references variable `c` from the main file.

![Image for post](./images/02_18.png)

![Image for post](./images/02_19.png)

## Init function

Like `main` function, `**init**` function is called by Go when a package is initialized. It does not take any arguments and doesnâ€™t return any value.

The `init` function is **implicitly** declared by Go, hence you can not reference it from anywhere (*or call it like* `*init()*`). You can have multiple `init` functions in a file or a package. Order of the execution of `init` function in a file will be according to the order of their appearances.

![Image for post](./images/02_20.png)

You can have `init` function anywhere in the package. These `init` functions are called in lexical file name order (***alphabetical order\***).

![Image for post](./images/02_21.png)

After all the`init` functions are executed, `main` function is called. Hence, the **main job of** `**init**` **function is to initialize global variables** that cannot be initialized in the global context. For example, initialization of an array.

![Image for post](./images/02_22.png)

Since, `for` syntax is not valid in package scope, we can initialize the array `integers` of size `10` using `for` loop inside `init` function.

## Package alias

When you import a package, Go create a variable using the package declaration of the package. If you are importing multiple packages with the same name, this will lead to a conflict.

```
// greet/parent.go
package greetvar Message = "Hey there. I am parent."// greet/greet/child.go
package greetvar Message = "Hey there. I am child."
```

![Image for post](./images/02_23.png)

Hence, we use **package alias**. We state a variable name in between `import` keyword and package name which becomes the new variable to reference the package.

![Image for post](./images/02_24.png)

In the above example, `greet/greet` package now is referenced by `child` variable. If you notice, we aliased `greet` package with an underscore.

Underscore is a special character in Go which acts as `null` **container**. Since we are importing `greet` package but not using it, Go compiler will complain about it. To avoid that, we are storing reference of that package into `_` and Go compiler will simply ignore it.

Aliasing a package with an **underscore** which seems to do nothing is quite useful sometimes when you want to **initialize** a package but not use it.

```
// greet/parent.go
package greetimport "fmt"var Message = "Hey there. I am parent."func init() {
  fmt.Println("greet/parent.go ==> init()")
}// greet/greet/child.go
package greetimport "fmt"var Message = "Hey there. I am child."func init() {
  fmt.Println("greet/greet/child.go ==> init()")
}
```

![Image for post](./images/02_25.png)

The main thing to remember is, **an imported package is initialized only once per package**. Hence if you have multiple import statements in a package, an imported package is going to be initialized only once in the lifetime of main package execution.

> *ğŸ’¡* If we use `*.*` (dot) as an alias like `*import . "greet/greet"*` then all the export members of `*greet*` package will be available in the local file block scope and we can reference `*Message*` without using qualifier `*child*`. Hence, `*fmt.Println(Message)*` would work just fine. This type of import is called as **Dot Import** and Go community is [**not very fond of it**](https://github.com/golang/go/issues/29326) as it can cause some issues.

------

# Program execution order

So far, we understood everything there is about packages. Now, letâ€™s combine our understanding of how a program initializes in Go.

```
go run *.go
â”œâ”€â”€ Main package is executed
â”œâ”€â”€ All imported packages are initialized
|  â”œâ”€â”€ All imported packages are initialized (recursive definition)
|  â”œâ”€â”€ All global variables are initialized 
|  â””â”€â”€ init functions are called in lexical file name order
â””â”€â”€ Main package is initialized
   â”œâ”€â”€ All global variables are initialized
   â””â”€â”€ init functions are called in lexical file name order
   
```

Here is a small example to prove it.

```
// version/get-version.go
package versionimport "fmt"func init() {
 fmt.Println("version/get-version.go ==> init()")
}func getVersion() string {
 fmt.Println("version/get-version.go ==> getVersion()")
 return "1.0.0"
}/***************************/// version/entry.go
package versionimport "fmt"func init() {
 fmt.Println("version/entry.go ==> init()")
}var Version = getLocalVersion()func getLocalVersion() string {
 fmt.Println("version/entry.go ==> getLocalVersion()")
 return getVersion()
}/***************************/// app/fetch-version.go
package mainimport (
 "fmt"
 "version"
)func init() {
 fmt.Println("app/fetch-version.go ==> init()")
}func fetchVersion() string {
 fmt.Println("app/fetch-version.go ==> fetchVersion()")
 return version.Version
}/***************************/// app/entry.go
package mainimport "fmt"func init() {
 fmt.Println("app/entry.go ==> init()")
}var myVersion = fetchVersion()func main() {
 fmt.Println("app/fetch-version.go ==> fetchVersion()")
 fmt.Println("version ===> ", myVersion)
}
```

![Image for post](./images/02_26.png)

------

# Installing 3rd party package

Installing a 3rd party package is nothing but cloning the remote code into a local `src/` directory. Unfortunately, Go does not support package version or provide package manager but a proposal is waiting [***here\***](https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md).

Go does not have a centralize official package registry, it asks you to provide hostname and path to the package.

```
$ go get -u github.com/jinzhu/gorm
```

Above command imports files from `http://github.com/jinzhu/gorm` URL and saves it inside `src/github.com/jinzhu/gorm` directory. As discussed in nested packages, you can import `gorm` package like below.

```
package mainimport "github.com/jinzhu/gorm"// use ==> gorm.SomeExportedMember
```

So, if you made a package and want people to use it, just publish it on GitHub and you are good to go. If your package is executable, people can use it as a command-line tool else they can import it in a program and use it as a utility module. The only thing they need to do is use the below command.

```
$ go get github.com/your-username/repo-name
```

------

# Migrate to Go Modules

Go provides a new feature called **Modules** which provides flexibility to manage your project and dependencies with ease. If you are working on Go packages, then you should consider **relocating** your project to Go Modules.



[åŸæ–‡é“¾æ¥](https://medium.com/rungo/everything-you-need-to-know-about-packages-in-go-b8bac62b74cc)